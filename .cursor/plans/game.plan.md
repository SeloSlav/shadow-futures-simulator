You are building a multiplayer economy simulator game using SpacetimeDB with a Rust server module and a React/TypeScript client (existing dashboard component is provided below). The current UI is a dashboard; convert it into a game.

Core thesis to communicate through gameplay:

- As reinforcement α rises past ~1 and churn is low, verified work becomes non-identifying (MI collapses). Players should discover this via emergent dynamics, not scripted events.
- Add ergodicity economics: multiplicative wealth with state-dependent volatility. Players should learn that time-average growth diverges from ensemble-average under volatility clustering.

Critical constraints (must follow):

- NO pre-scripted timeline shocks (no “year 12 AI happens”).
- Shocks may exist as labeled types, but must be generated endogenously via state-dependent stochastic processes (hazard rates) on the server.
- NO fixed collapse thresholds (“game over if X > Y”). Collapse must be endogenous loss of controllability: entry dries up, policy responsiveness fades, ruin cascades persist. You may use smooth “inertia” indicators computed from slopes/rates and multi-signal conditions, but not a single hard threshold.
- Avoid ideological scoring. Score is discounted cumulative net revenue adjusted for instability/ruin and survivability. Do not include “equality points” or moral metrics.
- Multiplayer from the start, but no user accounts. Use ephemeral identities: player chooses a name at run start; store a local token; server tracks players by SpacetimeDB identity/session. No email/password.

Architecture:

- Server authoritative simulation in Rust using SpacetimeDB tables + reducers.
- Deterministic PRNG on server seeded per-run, so runs are reproducible and leaderboard is meaningful.
- Client is a real-time dashboard + controls. Client sends policy updates; server ticks the sim and emits time-series samples.

Game pacing:

- Simulation tick rate: 1 second.
- “Year” is a derived clock for UI/summary only (default 150 seconds per year). No year cap.
- Client may run at x1/x2 display speed by skipping renders, but server tick is canonical.

What to build (deliverables):
1) SpacetimeDB schema (tables) and reducers in Rust:
Tables (minimum):

- Game: game_id, seed, started_at, tick, seconds_per_year, status
- Players: game_id, identity, name, joined_at, last_action_at
- Policy: game_id, identity (or game-wide if single governor), income_top_rate, cap_gains_rate, vat_rate, vat_rebate, estate_strength, enforcement_budget, stabilizer_strength
- EconomyState: game_id, alpha, lambda, churn, mi_bits, gini, top1, top10, gdp, debt, legitimacy, avoidance, volatility_sigma, ensemble_growth, timeavg_growth, ruin_rate, firm_count, worker_participation
- ShockLog: game_id, tick, shock_type, magnitude_json, short_label
- Timeseries: game_id, tick, alpha, lambda, churn, mi_bits, gini, top1, revenue, gdp, debt, legitimacy, avoidance, volatility_sigma, firm_count, worker_participation, ruin_rate, ensemble_growth, timeavg_growth

Reducers:

- create_game(seed?, seconds_per_year?) -> game_id (server picks seed if not provided)
- join_game(game_id, name)
- set_policy(game_id, policy_fields...) (rate limited; store per-player; optionally aggregate to a single effective policy using “governor” role or voting later; MVP can be single governor = first player)
- tick(game_id) (server invoked via scheduled tick or internal loop; advances sim by 1 second, updates state, emits Timeseries row; generates shocks endogenously)

Important: implement a deterministic PRNG (e.g., splitmix64/xorshift) keyed by (game.seed, tick) so every tick and shock draw is reproducible.

2) Economy update model (server-side, endogenous, no scripts):
State variables: alpha, lambda, churn; plus derived MI, concentration, GDP, debt, legitimacy, avoidance, volatility_sigma; plus coarse populations:

- Workers: participation rate, median wealth, ruin probability
- Firms: firm_count, entry_rate, exit_rate, market concentration
- Incumbents: dominant share proxy (top1)

Dynamics must satisfy:

- alpha has upward drift from scale forces + state feedback (higher concentration raises alpha drift). Policies can reduce alpha drift indirectly (antitrust proxy via enforcement+cap gains+rent taxes is later; MVP: enforcement+estate reduce effective reinforcement drift slightly, stabilizers reduce volatility).
- churn evolves endogenously (legitimacy and enforcement increase effective churn; high avoidance decreases it).
- lambda can drift down when alpha rises (effort becomes less visible), but stabilizers/competition policies can slow lambda decay.

Shocks:
Implement 3 shock families generated by hazard rates (no timeline):

- Scale shocks: increase alpha, maybe decrease lambda.
- Institutional shocks: move churn and avoidance and legitimacy.
- Volatility shocks: increase volatility_sigma (clustered volatility).

Hazard rates must be state-dependent:

- Scale shock hazard increases with Top1/Gini and decreases with churn.
- Institutional shock hazard increases when legitimacy is low or unemployment/ruin is high.
- Volatility shock hazard increases with debt, concentration, low legitimacy.

Each shock has a label (e.g., “Network acceleration”, “Compliance breakdown”, “Risk repricing”) but labels are not tied to years.

Taxes:
Compute tax revenue each tick/year from simplified bases:

- labor base ~ worker_participation * gdp_share_labor
- capital base ~ concentration * gdp_share_capital
- consumption base ~ gdp * consumption_share
Apply rates + avoidance/compliance to get realized revenue.
Enforcement reduces avoidance with diminishing returns.

Ergodicity:
Model multiplicative wealth for representative cohorts (not individuals):

- Wealth evolves with returns r_t = mu + sigma*eps
- time-average growth approx E[log(1+r)] and falls with sigma (volatility drag)
Track ensemble_growth and timeavg_growth separately.
Ruin_rate increases when volatility is high and stabilizers low.

Collapse/inertia:
Do NOT end the game with a threshold. Instead compute an “inertia index” for UI and scoring based on:

- low responsiveness (delta revenue / delta policy) over recent window
- declining entry (firm_count trend negative)
- MI trend near zero
- ruin_rate persistent
Provide this index to client.

3) Client integration:

- Replace local simulate() loop with a live subscription to Timeseries rows from SpacetimeDB.
- Keep existing charts but feed from Timeseries.
- Add policy controls that call set_policy reducer.
- Add an event log fed by ShockLog.
- Add a “start run” screen: choose name, create/join game.
- Add a leaderboard screen using final score computed on server:
Score = discounted sum of net revenue – penalties for persistent ruin/instability; bonus for longer survivability. No moral metrics.

4) Testing:

- Add Rust tests for determinism: same seed + same policy stream => identical Timeseries and ShockLog.
- Add test that policy changes have diminishing returns under high alpha/low churn (responsiveness drops).
- Add test that volatility increases ruin_rate and reduces timeavg_growth (ergodicity layer).

Implementation plan (MVP):

- Step 1: SpacetimeDB tables + create_game/join_game/set_policy + tick that updates a minimal EconomyState (alpha/lambda/churn + revenue).
- Step 2: Add shock engine (hazard-based) + ShockLog.
- Step 3: Add ergodicity (volatility + timeavg vs ensemble) + ruin + participation.
- Step 4: Hook existing React dashboard to Timeseries + policy reducers.
- Step 5: Add leaderboard scoring + retire run.

Use my existing dashboard component code as the UI base. Refactor it into ShadowFuturesGame.tsx but preserve charts and styling. Create server + client changes needed. Don’t invent unrelated features.